<!doctype html>
<html lang='en'>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ðŸŒ± Learning docs & notes about my Frontend Development journey, Leo de S.L.F.">
    <meta name="author" content="Leonardo de S.L.F"/>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="crossorigin">
    <link rel="stylesheet" href="/style/style.css"/>
    <link rel="stylesheet" href="/style/syntax-highlight.css"/>
    <link rel="stylesheet" href="/style/print.css" media="print"/>
    <link rel="stylesheet" href="/style/small.css" media="(max-width: 599px)"/>
    <title>Docs & Notes</title>
  </head>
  <body>
    <label id="dark-theme">
      <input id="dark-theme__input" type="checkbox"/>
      <span></span>
    </label>
    <script>
      const lastChoise = localStorage.getItem('color_scheme_choise');
      const prefersDark = window.matchMedia('(prefers-color-scheme: dark)');

      // Prioritize user preferences over system settings.
      const currentIsDark = lastChoise !== null
        ? lastChoise === 'true'
        : prefersDark.matches;

      // Checkbox (checked = dark, unchecked = light).
      const darkThemeCheckbox = document.getElementById('dark-theme__input');
      darkThemeCheckbox.checked = currentIsDark;
      darkThemeCheckbox.addEventListener('input', toggleTheme);

      if (currentIsDark) {
        document
          .documentElement
          .classList
          .add("dark");
      }

      function toggleTheme({target}) {
        localStorage.setItem('color_scheme_choise', target.checked);
        document
          .documentElement
          .classList
          .toggle("dark");
      }
    </script>
    
      <a id="home" href="/">ðŸŒ±</a>
      
    
    <h1>
      <a href="/">ðŸŒ± Docs & Notes</a>
    </h1>
    <main>
      <h2>Sorting Algorithms</h2>
<p>An algorithm is a <strong>set of well-defined instructions</strong> to solve a given problem, taking a set of inputs and producing a desired output.</p>
<p>Basic algorithm rules:</p>
<ul>
<li>Input and output should be <em>defined precisely</em>.</li>
<li>Each step should be <em>clear and unambiguous</em>.</li>
<li>It should be the <em>most effective way</em> to get a solution.</li>
<li>It should be defined as an <em>abstraction</em>, not as an implementation.</li>
</ul>
<h3>Developing a Good Algorithm</h3>
<p>The efficiency of data handling can be substantially increased if the data are sorted according to some <strong>criteria of order</strong>. Very <em>often, the sorting criteria are natural</em>, as in the case of numbers, or the numeric value of alphanumeric characters. Sorting can be made in <em>ascending or descending</em> order. Once the criterion is selected, the second step is <strong>how to sort</strong> the data using that criterion.</p>
<p>There are infinite ways to sort the data, not all of them are efficient. To decide which method is best, certain <strong>criteria of efficiency</strong> have to be established, and a <strong>method for quantitatively comparing</strong> different algorithms must be chosen, certain critical properties should be defined when comparing alternative methods. Two such properties to do that are the <strong>number of comparisons</strong> and the <strong>number of movements</strong>. <em>The efficiency of these two operations depend on the size of the data set</em>.</p>
<h3>Estimating Efficiency</h3>
<p>We need to measure <strong>how much time it takes</strong> for it to sort the data, but also need to get to know the <em>intelligence</em> of that method. For example, an algorithm can (it better should) <em>recognize an already sorted data set</em>, so it doesn't make any unnecessary movement or comparison. On the other hand it can be completely unaware of that fact. Determining the precise number of operations <strong>is not always necessary or possible</strong>. For this reason, <em>the number of comparisons and movements is approximated</em>.</p>
<p>The number of <strong>comparisons and movements</strong> can vary independently. An algorithm can be efficient on the former and perform poorly on the latter, or vice versa. They can always perform the same operations regardless of <strong>the initial ordering of data</strong>, others are more flexible. Some algorithms perform better on small data samples, others perform better on larger ones, so the <strong>size of the data sample</strong> is also important. The number of operations is often computed (if possible) for three case scenarios.</p>
<p>The three cases are:</p>
<ul>
<li><strong>Best case</strong>: when the data is already in order, <em>Big-O</em> notation.</li>
<li><strong>Worst case</strong>: the data is in reverse order, <em>Omega</em> notation.</li>
<li><strong>Average case</strong>: data consistently in random order, <em>Theta</em> notation.</li>
</ul>
<h3>Elementary Sorting Algorithms</h3>
<p>This kind of algorithm tends to be efficient for sorting a <em>small number of elements</em>. As the number of elements increases, efficiency decreases.</p>
<h4>Insertion Sort</h4>
<p>In insertion sort, given an item, <em>shift all greater-left items by one position</em> to finally put it in the right spot when there are no more greater-left items. It makes use of a key to temporarily hold the item's value.</p>
<pre class="language-txt"><code class="language-txt">insertion(array, n)<br>  for i = 1 to n - 1<br>    move +1 place all greater items than array[i] from its left<br>    put key in the right spot<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">insertion</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> key<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    key <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Selection Sort</h4>
<p>The selection sort algorithm takes, usually from left to right, a range of items in which we <em>localize the smallest one and swap it with the first one</em>, to then repeat the process with the remaining unordered ones. We loop until <code>n - 2</code> (inclusive) because if all items but the last have been already sorted, <code>n - 1</code> has to be the largest.</p>
<pre class="language-txt"><code class="language-txt">selection(array, n)<br>  for i = 0 to n - 2<br>    select the smallest item from array<br>    swap it with array[i]<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">selection</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">,</span> lowestIndex<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> lowestIndex <span class="token operator">=</span> i<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>lowestIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        lowestIndex <span class="token operator">=</span> j<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    <span class="token punctuation">[</span>array<span class="token punctuation">[</span>lowestIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>lowestIndex<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Bubble Sort</h4>
<p>A sort algorithm in which we <em>swap any unordered adjacent pair of items</em> from one edge of the array to the other. Any time we make a swap, another scan should be made to verify if the new positioning left all items in the right place.</p>
<pre class="language-txt"><code class="language-txt">bubble(array, n)<br>  for i = 0 to n - 2<br>    for j = n - 1 to i + 1<br>      if array[j] > array[j - 1]<br>        swap array[j] and array[j - 1]<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">bubble</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">>=</span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Comb Sort</h4>
<p>In comb sort the idea is quite similar to bubble sort, we still swap items, but this time, we <em>swap items with a greater gap between them</em>. We start from the largest possible gap, which is the array length, comparing the first and the last element. Then reduce the gap dividing it by a shrink factor, usually 1.3, and compare all possible pairs with that configuration, repeat the process while the gap is at least one (comparing adjacent items).</p>
<pre class="language-txt"><code class="language-txt">comb(array, n)<br>  gap = n<br>  while (gap / 1.3 > 1)<br>    swap unordered pairs<br>  // if (gap / 1.3 &lt; 1)<br>  scan again until no more swaps are made<br>    swap unordered pairs<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">comb</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> i<span class="token punctuation">,</span> j<span class="token punctuation">,</span> gap <span class="token operator">=</span> n<span class="token punctuation">;</span><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>gap <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">1.3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> gap<span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">let</span> again <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> again<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> again <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span> j <span class="token operator">></span> i<span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>        again <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h3>Efficient Sorting Algorithm</h3>
<p>Efficient algorithms can break the limit of <code>O(n^2)</code> of simpler sorting algorithms. They are better options for sorting a <em>large data set</em> than the elementary ones. The approach of <em>divide and conquer</em> is applied to first sort subarrays, making the overall state of the array closer to the best case scenario (an already sorted array), then the whole piece is sorted.</p>
<h4>Shell Sort</h4>
<p>The heart of shell sort is an ingenious division of the array into several subarrays, as described before for efficient algorithms in general. It's similar to insertion, but the trick is that <em>items spaced farther apart are compared first</em>, then the items closer to each other are compared, and so on, until adjacent items are compared on the last pass.</p>
<pre class="language-txt"><code class="language-txt">shell(array, n)<br>  compute gaps from gap = 1 to gap &lt; n<br>  for each gap from last to first<br>    for each logical subarray of items with gap distance between them<br>      sort subarray items with insertion sort<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">shell</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">const</span> gaps <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> i<span class="token punctuation">,</span> gap<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> gap <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> gap <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">*</span> gap <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    gaps<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> gap<span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">let</span> j<span class="token punctuation">,</span> k<span class="token punctuation">,</span> offset<span class="token punctuation">,</span> key<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">--</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    gap <span class="token operator">=</span> gaps<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>offset <span class="token operator">=</span> gap<span class="token punctuation">;</span> offset <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">*</span> gap<span class="token punctuation">;</span> offset<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> offset<span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> j <span class="token operator">+=</span> gap<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        key <span class="token operator">=</span> array<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span><br>        k <span class="token operator">=</span> j<span class="token punctuation">;</span><br>        <span class="token keyword">while</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> gap <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>k <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>          array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>k <span class="token operator">-</span> gap<span class="token punctuation">]</span><span class="token punctuation">;</span><br>          k <span class="token operator">-=</span> gap<span class="token punctuation">;</span><br>        <span class="token punctuation">}</span><br>        array<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> key<span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<p>More at <a href="https://oeis.org/A003462">Sequence A003462 (oeis.org)</a>.</p>
<h4>Heap Sort</h4>
<p>Heap sort uses an approach inherent to selection sort, but instead of starting from the smallest item, it <em>starts from the largest item and uses a max-heap tree</em>. We need to create a max-heap tree without actually creating a new data structure.</p>
<pre class="language-txt"><code class="language-txt">heap(array, n)<br>  convert the array into a max-heap<br>  for each unsorted item<br>    swap the largest one (the root) with the last one<br>    restore the max-heap property<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">moveDown</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">let</span> largest <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">while</span> <span class="token punctuation">(</span>largest <span class="token operator">&lt;=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">&lt;</span> last <span class="token operator">&amp;&amp;</span> array<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>largest <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      largest<span class="token operator">++</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>first<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token punctuation">[</span>array<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>first<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      first <span class="token operator">=</span> largest<span class="token punctuation">;</span><br>      largest <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> first <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>      largest <span class="token operator">=</span> last <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br><span class="token punctuation">}</span><br><br><span class="token keyword">function</span> <span class="token function">heap</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">let</span> i<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">.5</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token function">moveDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> i<span class="token punctuation">,</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token punctuation">[</span>array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token function">moveDown</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Quicksort</h4>
<p>Quicksort <em>divides the array into two subarrays and a key called bound</em> or pivot. The first one contains items less than or equal to the pivot, the second subarray includes items equal to or greater than the pivot. Then the same partition process is repeated for both subarrays, and so on, until there are only one-cell arrays that do not need to be sorted at all.</p>
<pre class="language-txt"><code class="language-txt">quicksort(array)<br>  if array.length > 1<br>    choose a bound (index)<br>      for each item of array<br>        put items smaller than array[bound] on its left<br>        put items greater/equal to array[bound] on its right<br>    if more elements need to be sorted for subarrayN<br>      quicksort(subarrayN)<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">quicksort</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">></span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    first <span class="token operator">??=</span> <span class="token number">0</span><span class="token punctuation">,</span> last <span class="token operator">??=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">const</span> bound <span class="token operator">=</span> array<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>first <span class="token operator">+</span> last<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> lower <span class="token operator">=</span> first<span class="token punctuation">,</span> upper <span class="token operator">=</span> last<span class="token punctuation">;</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>lower <span class="token operator">&lt;=</span> upper<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>lower<span class="token punctuation">]</span> <span class="token operator">&lt;</span> bound<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        lower<span class="token operator">++</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">while</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>upper<span class="token punctuation">]</span> <span class="token operator">></span> bound<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        upper<span class="token operator">--</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>lower <span class="token operator">&lt;=</span> upper<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        <span class="token punctuation">[</span>array<span class="token punctuation">[</span>lower<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>upper<span class="token operator">--</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span>array<span class="token punctuation">[</span>upper<span class="token punctuation">]</span><span class="token punctuation">,</span> array<span class="token punctuation">[</span>lower<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lower <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">></span> first<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      array <span class="token operator">=</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> first<span class="token punctuation">,</span> lower <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">if</span> <span class="token punctuation">(</span>lower <span class="token operator">&lt;</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      array <span class="token operator">=</span> <span class="token function">quicksort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> lower<span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Mergesort</h4>
<p>The key process here is to <em>merge sorted halves of an array into one sorted array</em>. The process of dividing arrays into two halves is done recursively and stops when the array has fewer than two items. Each resulting halve has to be sorted first to then be able to merge. Subarrays are logically separated, no new data structure is created.</p>
<pre class="language-txt"><code class="language-txt">mergesort(array) {<br>  if array.length > 1    <br>    array = mergesort(left half of array)<br>    array = mergesort(right half of array)<br>    merge both halves (create only one new-temporal data structure)<br>  return array<br>}</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">mergesort</span><span class="token punctuation">(</span><span class="token parameter">array<span class="token punctuation">,</span> first<span class="token punctuation">,</span> last</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  first <span class="token operator">??=</span> <span class="token number">0</span><span class="token punctuation">,</span> last <span class="token operator">??=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span><br>  <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">&lt;</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">const</span> mid <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>first <span class="token operator">+</span> last<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">.5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><br>    array <span class="token operator">=</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> first<span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    array <span class="token operator">=</span> <span class="token function">mergesort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> last<span class="token punctuation">)</span><span class="token punctuation">;</span><br>    <span class="token keyword">const</span> temp <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token keyword">let</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> left <span class="token operator">=</span> first<span class="token punctuation">,</span> right <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> right <span class="token operator">&lt;=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&lt;</span> array<span class="token punctuation">[</span>right<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><br>        temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>      <span class="token punctuation">}</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>left<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;=</span> last<span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      temp<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>right<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> first<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> last<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">[</span>i <span class="token operator">-</span> first<span class="token punctuation">]</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Radix Sort</h4>
<p>The radix approach is to <em>sort integers by each one of its digits</em>. For example, starting from the rightmost digit (the units), then the second rightmost digit (the tens) and so on, until all the digits of the longest number have been sorted, partially keeping the order of previous steps.</p>
<pre class="language-txt"><code class="language-txt">radix(array, n)<br>  for digit = 0 (rightmost) to 9 (leftmost)<br>    for i = 0 to n - 1<br>      put all items among piles 0 through 9 based on array[i]'s digit value<br>    merge all items from the piles into array<br>  return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">radix</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">const</span> piles <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> pilesN <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> i<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    piles<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>    pilesN<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">const</span> radix <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> digits <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> j<span class="token punctuation">,</span> pile<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> digit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> factor <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> digit <span class="token operator">&lt;</span> digits<span class="token punctuation">;</span> factor <span class="token operator">*=</span> radix<span class="token punctuation">,</span> digit<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      pile <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">/</span> factor<span class="token punctuation">)</span> <span class="token operator">%</span> radix<span class="token punctuation">)</span><span class="token punctuation">;</span><br>      piles<span class="token punctuation">[</span>pile<span class="token punctuation">]</span><span class="token punctuation">[</span>pilesN<span class="token punctuation">[</span>pile<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// "Enqueue".</span><br>    <span class="token punctuation">}</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>pile <span class="token operator">=</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> pile <span class="token operator">&lt;</span> radix<span class="token punctuation">;</span> pile<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> pilesN<span class="token punctuation">[</span>pile<span class="token punctuation">]</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>        array<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> piles<span class="token punctuation">[</span>pile<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// "Dequeue".</span><br>      <span class="token punctuation">}</span><br>      pilesN<span class="token punctuation">[</span>pile<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h4>Counting Sort</h4>
<p>Counting sort first <em>counts the number of times each integer occurs</em> using an array which is indexed with the value of the given integer.</p>
<pre class="language-txt"><code class="language-txt">counting(array, n)<br>  for i = 0 to n - 1<br>    add +1 to count[array[i]]<br>  for i = 0 to n - 1<br>    put i count[i] amount of times in array<br>return array</code></pre>
<pre class="language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">counting</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>  <span class="token keyword">const</span> n <span class="token operator">=</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span><br>  <span class="token keyword">const</span> count <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><br>  <span class="token keyword">let</span> i<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    count<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    count<span class="token punctuation">[</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">let</span> j<span class="token punctuation">,</span> k<span class="token punctuation">;</span><br>  <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>    <span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span> count<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> j <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> j<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><br>      array<span class="token punctuation">[</span>k<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> i<span class="token punctuation">;</span><br>    <span class="token punctuation">}</span><br>  <span class="token punctuation">}</span><br>  <span class="token keyword">return</span> array<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<h3>Comparative Table</h3>
<p><strong>Average benchmark</strong> results for each <em>algorithm</em> implementation sorting an average case collection on multiple <em>lengths</em> to compare its performance evolution. The best and second best algorithms for each collection length are highlighted.</p>
<p>Elementary Sorting Algorithms (algorithm vs collection lenght):</p>
<table>
<thead>
<tr>
<th></th>
<th><code>25</code></th>
<th><code>250</code></th>
<th><code>1,000</code></th>
<th><code>15,000</code></th>
<th><code>50,000</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Insertion Sort</em></td>
<td><strong>0.00063ms</strong></td>
<td><em>0.0153ms</em></td>
<td><em>0.1861ms</em></td>
<td><em>38.7ms</em></td>
<td><em>427ms</em></td>
</tr>
<tr>
<td><em>Selection Sort</em></td>
<td><em>0.00072ms</em></td>
<td>0.0311ms</td>
<td>0.3943ms</td>
<td>78.3ms</td>
<td>866ms</td>
</tr>
<tr>
<td><em>Bubble Sort</em></td>
<td>0.00099ms</td>
<td>0.0700ms</td>
<td>0.9445ms</td>
<td>339ms</td>
<td>4.2s</td>
</tr>
<tr>
<td><em>Comb Sort</em></td>
<td>0.00099ms</td>
<td><strong>0.0082ms</strong></td>
<td><strong>0.0654ms</strong></td>
<td><strong>1.57ms</strong></td>
<td><strong>6.60ms</strong></td>
</tr>
</tbody>
</table>
<p>Efficient Sorting Algorithm (algorithm vs collection lenght):</p>
<table>
<thead>
<tr>
<th></th>
<th><code>25</code></th>
<th><code>250</code></th>
<th><code>1,000</code></th>
<th><code>15,000</code></th>
<th><code>50,000</code></th>
<th><code>1,000,000</code></th>
</tr>
</thead>
<tbody>
<tr>
<td><em>Shell Sort</em></td>
<td><em>0.00081ms</em></td>
<td><em>0.0045ms</em></td>
<td><em>0.0554ms</em></td>
<td>1.39ms</td>
<td>5.90ms</td>
<td>229.3ms</td>
</tr>
<tr>
<td><em>Heap Sort</em></td>
<td>0.00117ms</td>
<td>0.0061ms</td>
<td>0.0571ms</td>
<td><em>1.38ms</em></td>
<td>5.60ms</td>
<td>176.6ms</td>
</tr>
<tr>
<td><em>Quicksort</em></td>
<td>0.00108ms</td>
<td>0.0076ms</td>
<td>0.0679ms</td>
<td>1.40ms</td>
<td><em>5.20ms</em></td>
<td><em>125.2ms</em></td>
</tr>
<tr>
<td><em>Mergesort</em></td>
<td>0.00189ms</td>
<td>0.0207ms</td>
<td>0.1239ms</td>
<td>2.55ms</td>
<td>10.1ms</td>
<td>290.6ms</td>
</tr>
<tr>
<td><em>Radix Sort</em></td>
<td>0.00603ms</td>
<td>0.0451ms</td>
<td>0.1798ms</td>
<td>2.80ms</td>
<td>9.40ms</td>
<td>207.6ms</td>
</tr>
<tr>
<td><em>Counting Sort</em></td>
<td><strong>0.00036ms</strong></td>
<td><strong>0.0022ms</strong></td>
<td><strong>0.0078ms</strong></td>
<td><strong>0.18ms</strong></td>
<td><strong>1.10ms</strong></td>
<td><strong>36.40ms</strong></td>
</tr>
</tbody>
</table>
<hr>
<p>Reference:</p>
<ul>
<li>Data Structures and Algorithms in C++ (page 491).</li>
<li>Introduction to Algorithms (page 16, 170, 194, 197).</li>
<li><a href="https://www.programiz.com/dsa">Learning DS &amp; Algorithms (programiz.com)</a>.</li>
</ul>

    </main>
    <footer>
      <p>
        Learning
        <a href="/">docs & notes</a>
        about my Frontend Development journey,
        <a href="https://www.leodeslf.com/">Leo de S.L.F</a>.
      </p>
    </footer>
  </body>
</html>