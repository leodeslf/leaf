<!doctype html>
<html lang='en'>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="ðŸŒ± My learning docs and notes.">
    <meta name="author" content="Leonardo de S.L.F"/>
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico"/>
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="crossorigin">
    <link rel="stylesheet" href="/style/style.css"/>
    <link rel="stylesheet" href="/style/syntax-highlight.css"/>
    <link rel="stylesheet" href="/style/print.css" media="print"/>
    <link rel="stylesheet" href="/style/small.css" media="(max-width: 599px)"/>
    <title>Docs & Notes</title>
  </head>
  <body>
    <h1>
      <a href="/">ðŸŒ± Docs & Notes</a>
    </h1>
    <main>
      <h2>Browser Rendering Optimization</h2>
<p>Course by Google.</p>
<h3>The Critical Rendering Path</h3>
<h4>Frames</h4>
<p>A modern device tends to draw <em>60fps</em> (frames per second) due to its screen refresh rate of 60Hz (in most of the cases), that's about 16ms between each new frame.</p>
<p>Our target as developers should be to make animations and transitions to render at 60fps consistently from start to finish. By doing so, we ensure to bring the best experience to the user by making a product that runs smoothly <em>avoiding juddering</em>.</p>
<h5>Juddering</h5>
<p>It happens when the <em>fps drops</em> to the point that it's easily noticeable by the human eye because the drawing process has been slowed down (or even worse, the whole page/app lacks performance for some reason).</p>
<h4>Rendering Pipeline</h4>
<ul>
<li><strong>JavaScript</strong>: It would be used to handle work that will result in visual changes, like animation functions, sorting data, or manipulating the DOM/CSSOM.</li>
<li><strong>Style</strong>: It can be affected from JavaScript or CSS by using animations, transitions, or the Web Animation API (Timing Model and Animation Model).</li>
<li><strong>Layout</strong>: It's the computation of each element's geometry (position, size).</li>
<li><strong>Paint</strong>: Once the layout is done, each element gets painted on the screen pixel by pixel on a process known as rastering.</li>
<li><strong>Compose</strong>: It's where the browser puts the inidividual layers toghether.</li>
</ul>
<p>There are three ways the render pipeline can make a frame:</p>
<ol>
<li>Layout, then Paint, then Composite</li>
<li>Paint, then Composite</li>
<li>Only Composite</li>
</ol>
<p>All of these cases will be the result of a Style change. A Style change that come from either JavaScript or CSS.</p>
<!-- http://blog.wilsonpage.co.uk/introducing-layout-boundaries/ -->
<h3>App Lifecycles (RAIL)</h3>
<p>The four mayor areas of a site/app life cycle:</p>
<ul>
<li><strong>Response</strong>: it's the time it takes to give feedback from the users input. If the response time gets longer than 100ms, it will be noticed as lagged.</li>
<li><strong>Animate</strong>: either JavaScript or CSS, triggered by the user or a style rule. Each frame should be done in less than 16ms to ensure animations run at 60fps.</li>
<li><strong>Idle</strong>: it begins immediately after the site/app loads and it's waiting for the user to interact, it's <em>when nothing happens</em>. During this state, we usually do the post-loading of anything that can wait and isn't included in the CRP (like images, videos, or any low-priority content). It's around 50ms long after the load.</li>
<li><strong>Load</strong>: it's the actual first load of the page and all it's required assets before becoming idle. It should take less than 1s.</li>
</ul>
<h3>Weapons of Jank Destruction</h3>
<p>Steps to ensure we run on a <em>proper environment</em>:</p>
<ol>
<li>Quit other apps.</li>
<li>Go incognito.</li>
<li>Focus on the cause of bottlenecks, not symptoms.</li>
<li>Measure first, then optimize.</li>
</ol>
<p>To cover most of the use case scenarios and make a proper rendering performance analisis, we need to test on different <em>devices</em> (Windows, Mac, Android) and <em>browsers</em> (Chrome, Edge, Firefox, IE), as they may have a different JavaScript and Rendering <em>Engine</em>, which may result on different behaviors and an overall performance gap, a gap that's quite big specially when talking about rendering.</p>
<p>Our primary tool is the browsers developers tool, the <em>DevTools</em> in Chrome, which is used to monitor the <em>Rendering Pipeline trace</em> (among other functionalities) from its <em>Performance tab</em> (previously Timeline), giving us access to valuable data like events, function calls, the line of code that fires them, timing, and more.</p>
<h3>JavaScript</h3>
<h4>Just In Time (JIT) Compilers</h4>
<p>JavaScript compilers do compile the source code immediately after the file is loaded, that means they <em>generate a new code</em> to be executed from the one we write in JavaScript. Different engines may vary on the way they compile giving different results. That's why micro-optimizations aren't that effective and, in some cases, it can get even worse depending on the engine.</p>
<h4>JavaScript Animations</h4>
<p>The proper tool to make animations in JavaScript is the <code>requestAnimationFrame</code> API which is a method used to <em>call a given function the next frame</em> before it repaints, a callback to that function is passed as an argument. The given function itself needs to call <code>requestAnimationFrame</code> again to keep the loop running as an animation. To stop it, we use <code>cancelAnimationFrame</code>. It's said <code>requestAnimationFrame</code> is one-shot.</p>
<!-- https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame -->
<h4>Web Workers</h4>
<p>JavaScript is a <em>single-thread environment</em>, that means that's not possible to run multiple scripts at the same time (in parallel). It was true until the invention of Web Workers. A Web Worker is a script that runs in a <em>background thread</em>, allowing us to run scripts that hanlde computationally intensive tasks without blocking the UI or other script in the main thread. Transferring data between a worker and a non-worker script can be achieved via a thread-like message passing.</p>
<p>Web Workers do have access to:</p>
<ul>
<li>The <code>navigator</code> object.</li>
<li>The <code>location</code> object.</li>
<li>The application cache.</li>
<li>Importing scripts using the <code>importScripts</code> method.</li>
<li>Spawning other workers, (among other features).</li>
</ul>
<p>Web Workers do NOT have access to:</p>
<ul>
<li>The DOM tree.</li>
<li>The <code>window</code> object.</li>
<li>The <code>document</code> object.</li>
<li>The <code>parent</code> object.</li>
</ul>
<!-- https://www.html5rocks.com/en/tutorials/workers/basics/ -->
<h4>JavaScript Memory Management</h4>
<p>JavaScript implements <em>Garbage Collection</em> (it's said it is garbage-collected), which means for us developers, we don't need to worry about pointers, deleting objects, or how to handle local variables as it gets done by the engine itself automatically. The dowside is that the garbage collector is <em>Script-Blocking</em>, and, in consequence, it can be Render-Blocking resulting in a noticeable freezzing of the page/app.</p>
<!-- https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management -->
<h3>Styles and Layout</h3>
<h4>Recalculating Styles</h4>
<p>The <em>performance cost</em> of the Style stage (&quot;Recalculate Style&quot; in DevTools) tends to <em>scale linearly</em> with the number of elements affected by style changes.</p>
<p>At this stage, the rendering engine has to, first, read the whole CSSOM to <em>identify matching selectors</em> for a given node/element, then <em>apply all of them</em>. There could be more than one selector pointing at the same element (different or even identical ones), as well as repeating rules affecting the same attributes, in such a case, the rule gets applied and overridden each time it appears.</p>
<p>Let the engine work faster:</p>
<ul>
<li>Reduce the number of style rules.</li>
<li>Reduce complex and deeply nested selectors.</li>
<li>Remove unused CSS.</li>
<li>Avoid redundancy.</li>
<li>Avoid overrides.</li>
</ul>
<h4>Layout and Reflows</h4>
<p>Some style changes trigger one of the most <em>expensive</em> processes in the rendering pipeline, the Layout stage (or Reflow). It's there where new sizes and positions get calculated for an element.</p>
<p>In fact, most of the times several nodes get affected from a single reflow, mainly for two reasons. The first one, a reflow on a single node can <em>alter the ones next to it</em>, or even its own parent (by shrinking and growing, for example). The second one, <em>reflows cascade down the hierarchy</em>, a reflow on a parent element triggers reflow on all its child nodes. A small reflow can easily trigger reflow on the entire page.</p>
<p>Reduce layout calculations:</p>
<ul>
<li>Target elements that are lower in the DOM tree.</li>
<li>Avoid changing layout properties (specialy animating them).</li>
<li>Use absolute positioning to separate layers.</li>
</ul>
<h4>Repainting</h4>
<p>As said before, Paint is the stage where shapes' pixels defined in Layout get filled out. Usually <em>it's less expensive than Layout</em>, however, for some properties to apply, it can still take a considerable amout of time, specially for properties like <code>box-shadow</code>.</p>
<p>Optimize the Paint process:</p>
<ul>
<li>Use <code>will-change</code> to specify which rules are likely to change in a near future.</li>
<li>Isolate nodes on their own layer to prevent repainting on sibling nodes.</li>
<li>Reduce the amount of changes that trigger repaints.</li>
<li>Use <em>Hardware Acceleration</em> (GPU).</li>
</ul>
<h5>Hardware Acceleration</h5>
<p>It's to <em>perform a task on the Graphics Processing Unit</em> (GPU) instead of the used by default Central Processing Unit (CPU), which is remarkably faster when dealing with pixel-by-pixel calculations, as the ones done in the Paint stage.</p>
<p>The browser <em>automatically defines which styles do run on the GPU</em> and which ones do not. However, there are properties that will always trigger Hardware Acceleration, we can use them to force the browser to render a given node always on the GPU, even when the visual result remains the same (e.g.: <code>transform: translate(0, 0);</code>).</p>
<p>Forcing the use of GPU:</p>
<ul>
<li>Set <code>opacity</code> to less than <code>1</code>.</li>
<li>Set <code>transform</code> to anything but <code>none</code>.</li>
</ul>
<!-- https://www.hongkiat.com/blog/writing-better-css/ -->
<!-- https://dev.opera.com/articles/css-will-change-property/ -->
<h4>Forced Synchronous Layout</h4>
<p>Layout Thrashing occurs when JavaScript <em>first writes, then reads</em> the DOM multiple times triggering reflow each time it happens. The rendering engine behaves as follows, <em>when the DOM is written to, Layout is invalidated</em>, new changes apply, and finally the document is reflowed.</p>
<p>The browser tends to wait for the current frame to finish, then it performs this reflow. But, when we read a geometric value from the DOM before the current frame to be finished, the browser needs to <em>force Layout to perform early</em> so we can read it, that behavior is known as Forced Synchronous Layout.</p>
<p>An ideal (but not realistic) solution would be to <em>re-order the execution</em> so that we first read the current DOM, then we write on it (invalidating the Layout, but not forcing it to perform as we aren't reading), and finally only one reflow is triggered at the end of the frame.</p>
<h5>Trigger Reflows Asynchronously</h5>
<p>As mentioned before, <code>requestAnimationFrame</code> executes a given function the next frame as soon as it starts. So it can perform <em>writes without triggering reflows</em> while not having to re-order the code, and keeping the reads synchronous on frame.</p>
<!-- http://blog.wilsonpage.co.uk/preventing-layout-thrashing/ -->
<!-- https://developers.google.com/web/fundamentals/performance/rendering/avoid-large-complex-layouts-and-layout-thrashing -->
<h3>Composing and Painting</h3>
<h4>Painting</h4>
<p>It's the process of <em>filling in pixels on the screen</em>, and it's often the <em>longest-running</em> of all tasks in the pipeline. That's why it's so important to optimize (or avoid) it.</p>
<p>Style rules that won't trigger Paint are <code>transform</code> and <code>opacity</code>, prefer these rules when dealing with animations. Any property apart from these two will always trigger Paint. A Layout change will always trigger Paint too, since affected elements need to &quot;fix&quot; their pixels.</p>
<p>How to reduce Paint work load:</p>
<ul>
<li><em>Avoid reflows</em> and, in consequense, painting.</li>
<li><em>Use alternative style rules</em> that won't trigger repaint.</li>
<li><em>Use layers</em> to isolate changes from a given element.</li>
<li><em>Reduce painting areas</em>, the less pixels to repaint, the better.</li>
</ul>
<!-- https://developers.google.com/web/fundamentals/performance/rendering/simplify-paint-complexity-and-reduce-paint-areas -->
<h5>Painting by Layers</h5>
<p>The browser is capable of painting not only into a single image in memory, but into multiple images, or <em>Compositor Layers</em>. Layers are one of the best options to isolate changes and prevent unnecessary work to be done, but we <em>shouldn't abuse of them</em>, as they require memory and management.</p>
<h5>Debugging Repaints</h5>
<p>We can see the screen areas that are being repainted by using the <strong>Paint flashing</strong> tool from the Rendering tab of the DevTools in Chrome.</p>
<h4>Composing</h4>
<p>It's the process of <em>mixing layers</em> on screen displayed as a single image.</p>
<h5>Promoting new layers</h5>
<p>A way to make that is to use the <code>will-change</code> rule, by passing any value that is related to a geometric/positioning property, like <code>top</code>, <code>left</code>, <code>hight</code>, or <code>width</code>, we (almost) ensure the browser will &quot;prepare&quot; for these changes by creating a new layer.</p>
<p>It's also possible to do that with the <code>transform</code> rule, with a neutral value if no visual changes need to be done (e.g.: <code>transform: translateZ(0)</code>), also known as the <em>no-transform hack</em>. It always triggers the creation of a new layer even for older browsers and Safari, something that won't happen if using <code>will-change</code>.</p>
<p>In a production environment it's often needed to use both rules, e.g.:</p>
<pre class="language-css"><code class="language-css"><span class="token selector">div</span> <span class="token punctuation">{</span><br>  <span class="token property">transform</span><span class="token punctuation">:</span> <span class="token function">translateZ</span><span class="token punctuation">(</span>0<span class="token punctuation">)</span><span class="token punctuation">;</span><br>  <span class="token property">will-change</span><span class="token punctuation">:</span> transform<span class="token punctuation">;</span><br><span class="token punctuation">}</span></code></pre>
<!-- https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count -->

    </main>
    <footer>
      <p>
        ðŸŒ± Learning
        <a href="/">docs & notes</a>
        about my Frontend Development journey,
        <a href="https://www.leodeslf.com/">Leo de S.L.F</a>.
      </p>
    </footer>
    <a id="go-to-top-btn" href="#">&gt;</a>
  </body>
</html>